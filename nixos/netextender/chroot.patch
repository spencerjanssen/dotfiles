diff --git a/pkgs/build-support/build-fhs-userenv/chrootenv/chrootenv.c b/pkgs/build-support/build-fhs-userenv/chrootenv/chrootenv.c
index dcb2e97aa93..8c8d9a64bf0 100644
--- a/pkgs/build-support/build-fhs-userenv/chrootenv/chrootenv.c
+++ b/pkgs/build-support/build-fhs-userenv/chrootenv/chrootenv.c
@@ -54,14 +54,16 @@ void bind_mount_item(const gchar *host, const gchar *guest, const gchar *name) {
     bind_mount(source, target);
 }
 
+void bind_mount_host(const gchar *host, const gchar *guest) {
+  g_autofree gchar *point = g_build_filename(guest, "host", NULL);
+  bind_mount(host, point);
+}
+
 void bind(const gchar *host, const gchar *guest) {
   mount_tmpfs(guest);
-  pivot_host(guest);
-
-  g_autofree gchar *host_dir = g_build_filename("/host", host, NULL);
 
   g_autoptr(GError) err = NULL;
-  g_autoptr(GDir) dir = g_dir_open(host_dir, 0, &err);
+  g_autoptr(GDir) dir = g_dir_open(host, 0, &err);
 
   if (err != NULL)
     fail("g_dir_open", errno);
@@ -70,7 +72,9 @@ void bind(const gchar *host, const gchar *guest) {
 
   while ((item = g_dir_read_name(dir)))
     if (!g_strv_contains(bind_blacklist, item))
-      bind_mount_item(host_dir, "/", item);
+      bind_mount_item(host, guest, item);
+  bind_mount_host(host, guest);
+  fail_if(chroot(guest));
 }
 
 void spit(const char *path, char *fmt, ...) {
@@ -105,7 +109,7 @@ int main(gint argc, gchar **argv) {
     uid_t uid = getuid();
     gid_t gid = getgid();
 
-    if (unshare(CLONE_NEWNS | CLONE_NEWUSER) < 0) {
+    if (unshare(CLONE_NEWNS) < 0) {
       int unshare_errno = errno;
 
       g_message("Requires Linux version >= 3.19 built with CONFIG_USER_NS");
@@ -116,14 +120,11 @@ int main(gint argc, gchar **argv) {
       fail("unshare", unshare_errno);
     }
 
-    spit("/proc/self/setgroups", "deny");
-    spit("/proc/self/uid_map", "%d %d 1", uid, uid);
-    spit("/proc/self/gid_map", "%d %d 1", gid, gid);
-
     // If there is a /host directory, assume this is nested chrootenv and use it as host instead.
     gboolean nested_host = g_file_test("/host", G_FILE_TEST_EXISTS | G_FILE_TEST_IS_DIR);
     g_autofree const gchar *host = nested_host ? "/host" : "/";
 
+    fail_if(mount(NULL, "/", NULL, MS_REC | MS_SLAVE, NULL));
     bind(host, prefix);
 
     // Replace /host by an actual (inner) /host.
